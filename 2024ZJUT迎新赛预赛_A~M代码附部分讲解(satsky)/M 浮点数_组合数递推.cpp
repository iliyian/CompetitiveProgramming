#include<bits/stdc++.h>
using namespace std;using ll=long long;const int M=998244353;
ll poww(ll bs,ll x){ll res=1;for(bs%=M;x;x>>=1,(bs*=bs)%=M)if(x&1)(res*=bs)%=M;return res;}
ll invv(ll bs){return poww(bs,M-2);}
int main()
{
	ios::sync_with_stdio(0);cin.tie(0);
	ll n,m,p;cin>>n>>m>>p;if(p==1){for(int i=0;i<=m;i++)cout<<n<<" \n"[i==m];return 0;}
	ll sp=(poww(invv(p),n)-1),A=invv(M+1-p)*(M-p)%M;
	for(ll i=0,dot,sum,ans=0;i<=m;i++)
	{
		if(!i)
		{
			dot=poww(p,n-1);
			sum=(poww(p,n)+M-1)*invv(p+M-1)%M;			
		}
		else
		{
			dot=dot*(n-1+i)%M*invv(i)%M*(M+1-p)%M;
			(sum+=dot*A)%=M;
		}
		(ans+=sum)%=M;
		cout<<(ans+sp*sum%M)%M<<" \n"[i==m];
	}
}
/*
(讲解建议看pdf)
*
共有n关(点0⁓n),每次挑战有p的概率通过,(1-p)的概率失败

抽象一个二维平面,点(i,j)代表现在在关卡i,手上还有j枚金币的状态,f(i,j)代表从该状态到达终点的期望步数
每步有p的概率走到点(i+1,j),有另(1-p)的概率走到点(i,j-1),走到i=n时停止;
特别地,f(i,-1)即f(0,0),代表失败且没有金币后回到原点
-----------------------------------------------------------------------
p=1时直接特判。
我们可以将全过程分为"第一次失败且没有金币"(事件S)之前和之后(如果事件S没有发生,"之后"就不存在):

对于"之前",研究每个状态{点(i,j),i∈[0,n),j=[0,m]}被经过(事件S之后不算)的概率:
它们只会被经过一次,且总需要花1步走出去,则"之前"这部分的期望步数为所有点被经过概率的总和,设其为Ans1
设g(i,j)为:点B比点A横坐标大i,纵坐标小j时,从点A开始按规则经过点B的概率,另设G(j)=Σ(i∈[0,n-1])g(i,j)
有Ans1=Σ(i∈[0,n),j=[0,m])g(i-0,m-j)=Σ(i∈[0,n-1],j=[0,m])g(i,j)=Σ(j=[0,m])G(j)

对于"之后",研究在每个j=0的点进入事件S的概率,有Ans2=G(i)*(1-p)*f(0,0)

需要的Ans=Ans1+Ans2,以下研究如何计算f(0,0)和各P(j)
-----------------------------------------------------------------------
(a).计算f(0,0):
另设h(i)=从关卡0走到i的期望步数,f(0,0)=h(n)
h(0)=0,考虑尝试从关卡i走到i+1的期望步数,有:
h(i+1)-h(i)=p*0{成功}+(1-p)*h(i+1){失败,从0开始走到i+1}+1{总得走一步的}
得h(i+1)=(h(i)+1)/p,[h(i+1)-1/(p-1)]=(1/p)*[h(i)-1/(p-1)],h(i)=[h(0)+1/(1-p)]*[(1/p)^i]-1/(1-p)=[(1/p)^i-1]/(1-p)
则F(0,0)=h(n)=[(1/p)^n-1]/(1-p)

(b).计算G(j)
g(i,j)=C(i+j,i)*[p^i]*[(1-p)^j],直接算G(j)是困难的...
不过对于j=0,g(i,0)=p^i,G(0)=(p^n-1)/(p-1)显然
考虑走到点(i,j)的前一步,有(i>0):
g(i,j)=p*g(i-1,j)+(1-p)*g(i,j-1)
Σ(i∈[0,n-1])g(i,j)=p*Σ(i∈[0,n-1])g(i-1,j)+(1-p)*Σ(i∈[0,n-1])g(i,j-1)
G(j)=p*(G(j)-g(n-1,j)+g(-1,j))+(1-p)*G(j-1)
G(j)=G(j-1)-p/(1-p)*g(n-1,j)
g(n-1,j)之间的递推只需若干次乘除,G(j)也是。
-----------------------------------------------------------------------
把以上所有东西结合起来就可以算出结果了!

代码中的A即"-p/(1-p)",sp即(1-p)*F(0,0)=[(1/p)^n-1],Ans2=P(m)*sp;
循环第i步的dot即g(n-1,j),sum即G(j),ans即Σ(j=[0,m])G(j)
*/